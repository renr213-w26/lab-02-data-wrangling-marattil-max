---
title: "Lab 2 - Data wrangling"
author: "Kathrine Marattil"
date: "Feb 10, 2026"
format: 
  html: default # for speed
  pdf: default # for final output
---

```{r}
#| eval: true
#| message: false

library(tidyverse)
```

# Questions

## Part 1

### Question 1

```{r}
midwest |>
 count(state)|>
  arrange(desc(n)) #arrange by number of counties

```

Illinois has the greatest amount of counties of 102, and Wisconsin has lowest amount of counties 72.

\newpage

### Question 2

```{r}

midwest |>
  count(county)|>
  filter(n ==5)
  
```

\newpage

### Question 3

```{r}
#a
popden <- midwest|>
  filter(popdensity > 25000)|>
  select(county, state, popdensity, poptotal, area)
popden
```

```{r}
#b
highest_popden <- midwest|>
  filter(popdensity == max(popdensity)) |>
  select(county, state, popdensity, poptotal, area)
highest_popden
```

\newpage

### Question 4

```{r}
midwest|>
  summarise(
    mean = mean(popdensity),
    Q1 = quantile(popdensity,0.25),
    Q3 = quantile(popdensity,0.75)
    )|>
  select(mean, Q1, Q3)

```

> The distribution of population density of counties is unimodal and extremely right-skewed. A typical Midwestern county has population density of `3097` people per unit area. The middle 50% of the counties have population densities between `622` to `2330` people per unit area.

\newpage

### Question 5

```{r}
midwest |>
  mutate(metro = if_else(inmetro == 1, "Yes", "No"))|>
  group_by(state)|>
  summarise(
    metro_pop = sum(metro == "Yes"),
    total_pop = n(),
    propor = metro_pop/total_pop
  )|>
  select(state,propor)
```

\newpage

### Question 6

```{r}
#a
a <- midwest|>
  filter ((percollege<10) & (percbelowpoverty >45))|>
  select (county,state, percbelowpoverty,percollege)
a
```

```{r}
#b
b<- midwest|>
  filter ((percollege > 40) & (percbelowpoverty <20))|>
  select (county,state, percbelowpoverty,percollege)
b
```

```{r}
#c
outliers<- midwest|>
  filter ((percollege > 40 & percbelowpoverty <20) |(percollege<10 & percbelowpoverty >45)) |>
  select (county,state, percbelowpoverty,percollege)|>
  arrange(county)
outliers
```

```{r}
#d
midwest <- midwest |>
  mutate(
    potential_outlier = if_else(county %in% pull(outliers, county),
      "Yes","No"))
midwest|>
  select(county, state, percbelowpoverty,percollege, potential_outlier )|>
  arrange(potential_outlier)


```

```{r}
#e
ggplot(midwest, aes(x = percollege, y = percbelowpoverty, colour = potential_outlier, shape = state )) +
  geom_point() +
  labs(
    title = "Population below the Poverty Line by Population with College Degree, by percentage",
    x = "Population with College Degree (%)",
    y = "Population below the Poverty Line (%)",
  )
```

\newpage

### Question 7

```{r}
#a
state_population <- midwest|>
  group_by(state)|>
  summarise(population = sum(poptotal)) |>
  arrange(desc(population))
state_population
```

```{r}
#b
state_population|>
  mutate(
    midwest_total = sum(population),
    prop = population / midwest_total
  )|>
  select(state, population, prop)|>
  arrange(desc(prop))

```

`#c`

Illinois has the greatest population of `11430602` with `27.2%` of the Midwest population.

Wisconsin has the least population of `4891769` with `11.6%` of the Midwest population.

\newpage

### Question 8

```{r}
state_poverty <- midwest|>
  group_by(state)|>
  summarise(mean_percbelowpoverty = mean(percbelowpoverty))|>
  select(state, mean_percbelowpoverty)

state_poverty|>
  arrange(mean_percbelowpoverty)

  
```

Indiana has the highest average percentage population below poverty line

\newpage

## Part 2

### Question 9

```{r}
df <- tibble(
  var_1 = c(10, 20, 30, 40, 50),
  var_2 = c("Pizza", "Burger", "Pizza", "Pizza", "Burger"),
  var_3 = c("Apple", "Apple", "Pear", "Pear", "Banana")
)

df
```

```{r}
df |>
  arrange(var_2)
```

Arrange sort the the dataframe based associated variable. If a numercial variable, the sort will be ascending numerically. If the variable is categorical, the sort will be ascending alphabetically

```{r}
df |>
  group_by(var_2)
```

Group_by groups the data as a function of the inserted variable, thus seperating the data so operation can be done on an individual scale.

```{r}
df |>
  group_by(var_2) |>
  summarize(mean_var_1 = mean(var_1))
```

As a factor of the values in var_2, this pipeline displays an average of the associated value in var_1 relating to burger or pizza respectively

```{r}
df |>
  group_by(var_2, var_3) |>
  summarize(mean_var_1 = mean(var_1))
```

This pipeline uses both var_2 and var_3 to group the average of var_1 for the associated variable. for example, the two occurances of pizza and pear resulted in the related var_1 value to be calculated as an average.

```{r}
df |>
  group_by(var_2, var_3) |>
  summarize(mean_var_1 = mean(var_1), .groups = "drop")

df |>
  group_by(var_2, var_3) |>
  mutate(mean_var_1 = mean(var_1))
```

The first pipeline, is similar to the last pipeline however it uses drop to stop grouping var_2 and Var_3

The second pipeline adds an additional column that respresents the average var_1 for the associated var_2 and var_3 . This is different from the first because it shows all columns and rows as individual entrys and not as grouped operations

